package org.example;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.concurrent.TimeUnit;
import io.github.cdimascio.dotenv.Dotenv;

public class App {

    // Configuration
    private static final String EVOSUITE_JAR = "evosuite-master.jar";
    private static final String SOURCE_DIR = "src/main/java";
    private static final String PROJECT_CLASSPATH = "target/classes";
    private static final String CLASS_TO_TEST = "org.example.Calculator";
    private static final String TEST_OUTPUT_DIR = "evosuite-tests";

    // API Configuration - USE AN ENVIRONMENT VARIABLE!
    private static final String GROQ_API_KEY = Dotenv.load().get("GROQ_API_KEY");
    private static final String GROQ_API_URL = "https://api.groq.com/openai/v1/chat/completions";
    private static final String GROQ_MODEL = "meta-llama/llama-4-maverick-17b-128e-instruct"; // A very capable model

    // JSON Helper
    private static final Gson GSON = new GsonBuilder().create();

    // Data Classes for JSON
    static class Message { String role; String content; Message(String r, String c) { role=r; content=c; } }
    static class Choice { Message message; }
    static class ChatResponse { List<Choice> choices; }
    static class ChatRequest { List<Message> messages; String model; ChatRequest(List<Message> m, String mo) { messages=m; model=mo; } }

    public static void main(String[] args) throws IOException, InterruptedException {
        if (GROQ_API_KEY == null || GROQ_API_KEY.isBlank()) {
            System.out.println("❌ FATAL ERROR: GROQ_API_KEY environment variable not set. Please set it and try again.");
            return;
        }

        System.out.println("Starting EvoSuite Refactoring Process (Java version)...");
        String rawTestPath = runEvoSuite();

        if (rawTestPath != null && !rawTestPath.isBlank()) {
            System.out.println("\n✅ EvoSuite generation successful.");
            refactorWithLLM(rawTestPath);
        } else {
            System.out.println("\n❌ EvoSuite generation failed. Aborting.");
        }
    }

    private static String runEvoSuite() throws IOException, InterruptedException {
        System.out.println("--- Step 1: Running EvoSuite to generate raw test ---");
        List<String> command = List.of("java", "-jar", EVOSUITE_JAR, "-class", CLASS_TO_TEST,
                "-projectCP", PROJECT_CLASSPATH, "-Dtest_dir=" + TEST_OUTPUT_DIR);

        ProcessBuilder pb = new ProcessBuilder(command).inheritIO();
        Process process = pb.start();
        process.waitFor(5, TimeUnit.MINUTES);

        String expectedFilePath = TEST_OUTPUT_DIR + File.separator + CLASS_TO_TEST.replace('.', File.separatorChar) + "_ESTest.java";
        if (process.exitValue() == 0 && Files.exists(Paths.get(expectedFilePath))) {
            return expectedFilePath;
        }
        return null;
    }

    private static void refactorWithLLM(String rawTestFilePath) throws IOException, InterruptedException {
        // ... This method is fine, no changes needed from your last version. We'll put it here for completeness.
        System.out.println("\n--- Step 2: Refactoring generated code with Groq LLM ---");

        String rawCode = Files.readString(Paths.get(rawTestFilePath));
        String sourceFilePath = SOURCE_DIR + File.separator + CLASS_TO_TEST.replace('.', File.separatorChar) + ".java";
        String sourceCode = Files.readString(Paths.get(sourceFilePath));

        System.out.println("Successfully read raw test file and source context file.");

        String prompt = "You are an expert senior Java developer assigned to refactor a JUnit test file. The original test was generated by EvoSuite and is difficult to read.\n\n"
                + "You will be given two pieces of code:\n"
                + "1. The original Java class under test.\n"
                + "2. The raw EvoSuite-generated JUnit test for that class.\n\n"
                + "Your task is to refactor the JUnit test code using the original source as context. Make the test readable, maintainable, and clean for professional developers. Follow these rules STRICTLY:\n"
                + "1.  **Rename Test Methods:** Change method names like `test01` to a descriptive pattern: `test<MethodName>_<Scenario>_<ExpectedResult>`. E.g., `test01` → `testAdd_WithPositiveNumbers_ShouldReturnCorrectSum`.\n"
                + "2.  **Rename Variables:** Change cryptic names like `calculator0`, `int0`, etc., to meaningful names like `calculator`, `firstNumber`, `expectedSum`.\n"
                + "3.  **Add Javadoc Comments:** Add a short Javadoc above each test method describing what is being tested and why.\n"
                + "4.  **DO NOT CHANGE LOGIC:** Do not modify any assertions (`assertEquals`, `assertThrows`, etc.), method calls, or test behavior. Preserve all logic exactly as-is.\n"
                + "5.  **PRESERVE EVO SUITE SCAFFOLDING:** Keep EvoSuite-specific methods (e.g., `EvoSuite.setClassLoader()`, `EvoSuite.resetClasses()`, `verifyException`). Do not change or remove them.\n"
                + "6.  **DO NOT CHANGE THE CLASS NAME.**\n"
                + "7.  **CODE STYLE:** Use standard Java formatting, consistent indentation, and place `@Test` annotations directly above each method.\n"
                + "8.  **OUTPUT FORMAT:** Output ONLY the full refactored Java code in a single ```java code block. No explanations, commentary, or markdown outside the code block.\"\n\n"
                + "---\n"
                + "**Original Java Class Under Test:**\n"
                + "```java\n" + sourceCode + "\n```\n"
                + "---\n"
                + "**EvoSuite-Generated Test to Refactor:**\n"
                + "```java\n" + rawCode + "\n```";


        ChatRequest requestPayload = new ChatRequest(List.of(new Message("user", prompt)), GROQ_MODEL);
        String jsonBody = GSON.toJson(requestPayload);

        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(GROQ_API_URL))
                .header("Content-Type", "application/json")
                .header("Authorization", "Bearer " + GROQ_API_KEY)
                .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
                .build();

        System.out.println("Sending request to Groq API for context-aware refactoring...");
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

        if (response.statusCode() == 200) {
            ChatResponse chatResponse = GSON.fromJson(response.body(), ChatResponse.class);
            String llmMessageContent = chatResponse.choices.get(0).message.content;

            String refactoredCode = null;
            String lowerCaseContent = llmMessageContent.toLowerCase();
            int startBlock = lowerCaseContent.indexOf("```java");
            int endBlock = lowerCaseContent.lastIndexOf("```");

            if (startBlock != -1 && endBlock > startBlock) {
                refactoredCode = llmMessageContent.substring(startBlock + 7, endBlock).trim();
            } else {
                refactoredCode = llmMessageContent.trim();
            }

            if (refactoredCode != null && !refactoredCode.isBlank()) {
                validateAndSave(refactoredCode, rawTestFilePath);
            } else {
                System.out.println("❌ Error: LLM returned an empty or invalid response.");
            }
        } else {
            System.out.println("❌ API Error: " + response.statusCode() + " | " + response.body());
        }
    }

    private static void validateAndSave(String refactoredCode, String originalFilePath) throws IOException, InterruptedException {
        System.out.println("\n--- Step 3: Validating refactored code by compiling ---");
        Path originalFile = Paths.get(originalFilePath);

        // --- NEW LOGIC TO PRESERVE THE ORIGINAL EVO SUITE FILE ---
        // 1. Define the new name for the original file.
        Path preservedOriginalFile = originalFile.getParent().resolve(originalFile.getFileName().toString().replace(".java", ".original.java"));

        // 2. Rename the raw EvoSuite test file (e.g., move Calculator_ESTest.java to Calculator_ESTest.original.java).
        try {
            Files.move(originalFile, preservedOriginalFile, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Preserved original EvoSuite test as: " + preservedOriginalFile.getFileName());
        } catch (IOException e) {
            System.err.println("❌ Could not rename original EvoSuite file: " + e.getMessage());
            // We can still continue, but the original will be lost if the process succeeds.
        }
        // --- END OF NEW LOGIC ---

        Path tempDir = Files.createTempDirectory("refactor-validation");
        // We will compile the temporary file with the original name.
        Path tempFile = tempDir.resolve(originalFile.getFileName());
        Files.writeString(tempFile, refactoredCode);

        Path scaffoldingFile = originalFile.getParent().resolve(originalFile.getFileName().toString().replace(".java", "_scaffolding.java"));
        Path tempScaffoldingFile = null;
        if (Files.exists(scaffoldingFile)) {
            System.out.println("Found scaffolding file: " + scaffoldingFile.getFileName());
            tempScaffoldingFile = tempDir.resolve(scaffoldingFile.getFileName());
            Files.copy(scaffoldingFile, tempScaffoldingFile);
        }

        String currentClasspath = System.getProperty("java.class.path");
        String evosuiteRuntimeJarPath = new File("evosuite-standalone-runtime-1.2.0.jar").getAbsolutePath();
        String fullClasspath = currentClasspath + File.pathSeparator + evosuiteRuntimeJarPath;

        System.out.println("Using FINAL classpath for validation: " + fullClasspath);

        List<String> compileCommand;
        if (tempScaffoldingFile != null) {
            compileCommand = List.of("javac", "-cp", fullClasspath, tempFile.toString(), tempScaffoldingFile.toString());
        } else {
            compileCommand = List.of("javac", "-cp", fullClasspath, tempFile.toString());
        }

        ProcessBuilder pb = new ProcessBuilder(compileCommand).redirectErrorStream(true);
        Process process = pb.start();
        String compilerOutput = new String(process.getInputStream().readAllBytes());
        process.waitFor(30, TimeUnit.SECONDS);

        if (process.exitValue() == 0) {
            System.out.println("✅✅✅ VICTORY! Validation successful! The refactored code compiles correctly. ✅✅✅");
            // --- CHANGE: Save the validated code to the ORIGINAL filename ---
            Files.writeString(originalFile, refactoredCode);
            System.out.println("Saved readable and validated test to: " + originalFile.getFileName());
        } else {
            System.out.println("❌ Validation FAILED. The LLM-generated code has compilation errors.");
            System.out.println("Compiler Output:\n" + compilerOutput);
            Path failedFile = originalFile.getParent().resolve(originalFile.getFileName().toString().replace(".java", "_refactor_failed.java"));
            Files.writeString(failedFile, refactoredCode);
            System.out.println("The faulty refactored code has been saved to: " + failedFile.getFileName());
        }

        Files.walk(tempDir).sorted(java.util.Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
    }
}